= ファイルシステムイベントとは

日頃、「ファイルが更新や追加されたら何か処理をする」ということは常日頃発生します。例えば、セキュリティソフト。セキュリティソフトは、ファイルが追加、更新されたら、そのファイルが問題無いか即座にチェックする必要があります。他にも、Dropboxなどのファイル同期・バックアップソフトもそうです。ファイルが変更されたら、即座に同期する事を多くのユーザは期待しているでしょう。

このように、ファイルの変更された場合に何か処理をする、というニーズは多くあります。この処理は、多くの場合、「ファイルシステムイベント」という機能を使用し実装されています。しかし、この処理がどのように実装されているかについては知らない方もいらっしゃるかと思います。この本は、その「ファイルシステムイベント」について説明した本です。

== 実装方式

ファイルの変更監視の実装方式は、大きく、ポーリングによる実装と、OSが提供しているAPIを使用した実装の2つの実装があります。それぞれについて見ていきましょう。

=== ポーリング

特別なAPIなどは使わず、スレッドなどを用いて、監視したいファイルやディレクトリに対して定期的に変更があったかを確認する方式です。

ポーリングのメリットとして、実行される環境にか依存せず、同じ機能が提供出来る、という事が挙げられます。後述するOSが提供しているAPIを使用した場合だと、OS毎に提供されている機能が事なり、OS間で挙動の差異が発生してしまいます。ポーリングだとそのような事がありません。

デメリットとして、変更が正確に把握することが難しい事が挙げられます。例えば、ファイルの更新があったかどうかの間に、ファイルの更新と削除が連続して行われた場合、更新の変更に気付くのが難しくなってしまいます。また、監視するファイルが数ファイルであればどうにかなるかもしれませんが、監視するファイルが複数ディレクトリに跨り数百あるような場合、更新があったかのチェックをするだけでもリソースを消費してしまい、負荷が掛ってしまう可能性があります。

このような理由により、現在は、OSが提供しているAPIを利用するのが一般的で、何らかの理由によりそれらのAPIが使用出来ないときの為のセーフティネットとしてポーリングの実装を提供、という形を取るライブラリが多いようです。もし自力でファイル変更監視を行うライブラリの実装を行うような場合は、余程特殊な事情が無い限り、後述するOSが提供するAPIを使用した実装を行うと良いでしょう。

=== OSが提供しているAPI

さて、先に説明した通り、ポーリングではファイル変更監視を正確に行うのは難しいです。しかし、昨今のOSは、OS側でファイル変更監視の為の仕組みが提供されています。一般的にそれらの仕組みは、監視したファイルやディレクトリをAPIで指定->指定したファイルやディレクトリで変更があったら変更内容を取得、という事が出来るようになっています。

残念ながら、これらのAPIは標準化はされておらず、OS毎に提供されている機能に差異があります。例えば、macOSではディレクトリを再帰的に監視する為のAPIが提供されていますが、Linuxには同等のAPIがありません。そのため、OSが提供しているAPIをそのまま使用した場合、提供する機能に差異が発生してしまいます。

それらの差異をどう対処しているかはAPIを実装しているライブラリ毎に異なります。ライブラリについての話の前に、まずOSが提供している機能について見ていきましょう。

= OS毎の話

== Linux

まずはLinuxについて見ていきたいと思います。

=== dnotify

Linuxに初めて導入されたファイルシステムイベント監視の仕組みは、dnotifyという機能でLinux 2.4.0で導入されました。dnotifyはディレクトリ自体、もしくはその内部のファイルに変更がかかったときに、ユーザアプリケーションにその変更を通知する事を目的として提供されていました@<fn>{dnotify}。変更の通知はシグナル送信により行われます。
//footnote[dnotify][dnotifyの先頭の"d"は、"directory"の"d"らしいです。]

最初に提供されたAPIという事もあり、dnotifyには、

・個別のファイルの監視が行えない。

・通知される情報が少ない(シグナル番号とファイルディスクリプタのみ)。

・監視するディレクトリ毎にファイルディスクリプタをオープンする必要がある。

・通知方法にシグナルを使用しているが、シグナルが非同期で送信されるため、競合状態やエラーが発生しやすかった。また、デフォルトでSIGIOを使用していたが、SIGIOはキューイングされないので、通知が欠落する事があった。

等々の問題がありました。そのため、後述するinotifyに置き換えられ、現在は使用されなくなっています。

=== inotify

前述したdnotifyの問題を解決する為に登場したのがinotify@<fn>{inotify}です。inotifyはLinux 2.6.13で導入されました。
//footnote[inotify][inode-based file event notificationsの略。]

inotifyは、dnotifyの問題点を大幅に改善しました。個別のファイルを監視できるようになり、通知される情報も豊富になりました。具体的には、どのファイルで何の変更が発生したかを詳細に知ることができるようになっています。

inotifyはinode@<fn>{inode}ベースの通知であり、ディレクトリ単位での再帰的な自動監視は行いません。再帰的に監視したい場合は、利用する側がディレクトリツリーを辿ってそれぞれを監視対象に追加する必要があります。
//footnote[inode][Unix系ファイルシステムで使われているデータ構造。inodeはファイルの実体（データブロック）や属性（パーミッション、所有者、タイムスタンプなど）への参照を保持し、ファイル名はそのinodeへの参照（ディレクトリエントリ）として扱われます。ファイルシステム内で一意の番号(inode番号)を持っています。]

=== fanotify

inotifyがリリースされた後、さらに高度なファイルシステム監視機能として、fanotify@<fn>{fanotify}がLinux 2.6.36で導入されました。
//footnote[fanotify][fscking all notificationの略。]

inotifyは、イベント発生元の情報(プロセスIDやユーザID)がとれない、ゲートキーピング機能<@gatekeeping>{gatekeeping}が無い、NFSのようなリモートファイルシステムのイベントを取得出来ない、等の問題あります。

これは、アンチウイルスソフトのようなセキュリティ関連のアプリケーションで問題になっていたそうです。そこで生まれたのがfanotifyです。
fanotifyは、inotifyとは異なるアプローチを取っています。inotifyが特定のファイルやディレクトリを監視するのに対し、fanotifyはファイルシステム全体を監視することができます。また、先に記載した問題も解消されています。
//footnote[gatekeeping][作に介入して許可・拒否等の処理を行うための機能。]

ただし、fanotifyを使用するには管理者権限（CAP_SYS_ADMIN）が必要です。そのため、特別な要件が無い一般的なアプリケーションでは、引き続きinofityが使われる事が多いです。

== *BSD

次に、BSD系OSについて見ていきましょう。

=== kqueue

BSD自体にはファイルシステム監視機能はありませんでした。しかし、子孫であるFreeBSDには、4.1からkqueue@<fn>{kqueue}という機能が追加されました。
//footnote[kqueue][Kernel Queuesの略。]

kqueueは、元々Iは/O多重化（複数のファイルディスクリプタの状態変化を効率的に監視する）を目的として設計されましたが、ファイルシステムイベントやプロセス、シグナル、タイマーなど、様々な種類のイベントを統一的に扱えるようになっています。

ファイルやディレクトリの変更（作成、削除、リネーム、属性変更など）を検知できるようになっていますが、inotify同様、サブディレクトリやファイルを自動で再帰的に監視する機能はありません。

kqueueはその後、NetBSD、OpenBSD及びDragonFly BSDでもサポートされ、BSD系ではデファクトになりました。

== macOS

続いてmacOSについて見ていきましょう。macOSが使用しているDarwinというOSがBSDをベースにしており、他のBSD同様に、kqueueがサポートされています。それに加えて、macOSでは、FSEvents@<fn>{FSEvents}という機能も使えるようになっています。次のセクションで詳細を見ていきましょう。
//footnote[FSEvents][File System Eventsの略。]

=== FSEvents

FSEventsは、macOSで提供されるファイルシステムイベント通知の仕組みです。FSEventsはディレクトリを単位として変更を記録・通知する設計になっており、ディレクトリ階層に対して再帰的に監視が可能です。ディレクトリを単位としているため、ファイル単位の細かなイベントは提供しないようになっています。
また、変更をバッファし、ある程度まとめて配信するようになっています。そのため、細かなファイルの変更を検知して向かない仕様になっています。変わりに、ディレクトリ階層に対してはkqueueよりも効率的に動作するようになっており、Time Machineのようなファイルシステム全体に対して処理を行う、というような用途に適しています。

== Windows

=== FindFirstChangeNotification

FindFirstChangeNotificationは、Windowsで最初に提供されたディレクトリ変更監視のAPIです。Windows 95時代から利用可能で、比較的シンプルな設計になっています。
APIにはディレクトリを指定出来るようになっており、指定したディレクトリに変更があった場合通知がされます。ディレクトリの監視はサブディレクトリも含めて再帰的に監視することができます。
しかし、通知は、単に変更があったかどうかだけが通知され、どのファイルに変更があったか、などの詳細情報は通知されません。

=== ReadDirectoryChangesW

ReadDirectoryChangesW@<fn>{ReadDirectoryChangesW}は、Windows NT 4.0で導入されたより高機能なディレクトリ変更監視APIです。
FindFirstChangeNotificationでは得られない詳細な変更情報(変更されたファイル名や変更の内容)を取得出来たり、監視する変更の種類をフィルター出来るようになっています。
//footnote[ReadDirectoryChangesW][末尾の"W"までが関数名です。Win32では、文字列の符号化方法がANSI互換文字列の場合末尾が"A"、ワイド文字列の場合"W"が使われるようになっています。FindFirstChangeNotificationについては、「FindFirstChangeNotificationA」と「FindFirstChangeNotificationW」の両方が存在しています。]


=== USNジャーナル

Windowsには、USNジャーナル（Update Sequence Number Journal）というボリュームに加えられた変更の記録を維持する為の機能があります。USNジャーナルは、NTFSファイルシステムで提供される低レベルなファイル変更追跡機能で、ファイルやディレクトリに対するあらゆる変更操作を時系列で記録します。
当然、ファイルの作成、削除、リネーム等の変更も記録されています。またUSNジャーナルは、APIでデータを取得する事が出来、データの取得を行った位置を保存しておくことで、その位置から変更があった情報だけ取得する、ということも出来るようになっています。

ファイルシステム全体を監視するため、個別にディレクトリも指定する必要があります。しかし、広域な情報にアクセス出来るため、USNジャーナルにアクセスするには、通常管理者権限が必要です。
fanotifyのように、アンチウイルスソフトのように、管理者権限でファイルシステム全体の変更を取得したい場合にのみ使用され、特別な要件が無い一般的なアプリケーションでは、ReadDirectoryChangesWが使われる事が多いようです。

== その他

ここまで記述した以外にも、SolarisにはEvent Portsが、AIXにはAHAFSと呼ばれる機能がありますが、本書ではこれらの詳細は割愛させていただきます。
